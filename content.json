{"meta":{"title":"Zhumark's Blog","subtitle":"时过境迁，物是人非","description":null,"author":"Zhumark","url":"http://www.zhumark.cn"},"pages":[{"title":"About me","date":"2017-08-09T11:56:36.000Z","updated":"2017-08-09T12:20:18.722Z","comments":false,"path":"about/index.html","permalink":"http://www.zhumark.cn/about/index.html","excerpt":"","text":"Hello，My name is Wei Dong.I study at the Software School,XiDian University Now. Here is my contact information: QQ: 1491579705 Email:1491579705@qq.com If you want to know more,I will be very happy to communicate with you. Thank you!"},{"title":"Categories","date":"2017-08-09T12:02:31.000Z","updated":"2017-08-09T12:03:59.023Z","comments":false,"path":"categories/index.html","permalink":"http://www.zhumark.cn/categories/index.html","excerpt":"","text":""},{"title":"All tags","date":"2017-08-09T11:50:52.000Z","updated":"2017-08-09T11:52:09.766Z","comments":false,"path":"tags/index.html","permalink":"http://www.zhumark.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2017-11-02T07:13:20.169Z","updated":"2017-11-02T07:13:20.169Z","comments":true,"path":"2017/11/02/hello-world/","link":"","permalink":"http://www.zhumark.cn/2017/11/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Linux 驱动开发之字符设备","slug":"drivers","date":"2017-03-22T15:57:41.000Z","updated":"2017-08-09T12:07:01.097Z","comments":true,"path":"2017/03/22/drivers/","link":"","permalink":"http://www.zhumark.cn/2017/03/22/drivers/","excerpt":"在Linux设备驱动中，相对简单的就属字符设备。可即使是这样，其开发的流程也比较复杂，相关知识也比较庞杂。本文就其内容简单梳理了字符设备驱动开发的流程和关键点。","text":"在Linux设备驱动中，相对简单的就属字符设备。可即使是这样，其开发的流程也比较复杂，相关知识也比较庞杂。本文就其内容简单梳理了字符设备驱动开发的流程和关键点。 Linux 设备分类在 Linux 系统中，设备驱动主要分为三大类：字符设备、块设备和网络设备。 字符设备：字符设备是指每次与系统传输单个个字符的设备。这些设备不能随机读取设备内存中的某一数据，要按照先后顺序来读取数据。字符设备是面向流的设备，常见的字符设备有鼠标、键盘、串口、控制台和 LED 设备等。 块设备：块设备是指可以从设备的任意位置读取一定长度数据的设备。常见的块设备包括硬盘、磁盘、U 盘和 SD 卡等。 网络设备：网络设备在Linux系统中是一类比较特殊的设备，它不像字符设备或者块设备那样对应设备文件节点访问，内核也不再通过read，write等调用去访问网络设备。网络设备的驱动程序是内核代码的一部分，其地址空间是内核的地址空间。 每一个字符设备或块设备都在/dev目录下对应一个设备文件。Linux 用户程序通过设备文件（或称设备节点）来使用驱动程序操作字符设备和块设备。 几个关系字符设备、字符设备驱动与用户空间访问该设备的程序三者之间的关系。 如图，在 Linux 内核中使用cdev结构体来描述字符设备，通过其成员dev_t来定义设备号（分为主、次设备号）以确定字符设备的唯一性。通过其成员file_operations来定义字符设备驱动提供给VFS的接口函数，如常见的open()、read()、write()等。 在Linux字符设备驱动中，模块加载函数通过 register_chrdev_region( ) 或 alloc_chrdev_region( )来静态或者动态获取设备号，通过 cdev_init( )建立cdev与file_operations之间的连接，通过 cdev_add( )向系统添加一个cdev以完成注册。模块卸载函数通过 cdev_del( )来注销cdev，通过 unregister_chrdev_region( )来释放设备号。 用户空间访问该设备的程序通过 Linux 系统调用，如 open( )、read( )、write( )，来“调用” file_operations这个操作集，操作集中的函数就是字符设备驱动提供给VFS的接口函数。 字符设备驱动模型 驱动初始化分配 cdev在 2.6 的内核中使用 cdev结构体来描述字符设备，在驱动中分配cdev,其实主要是分配一个cdev结构体与申请设备号，以按键驱动为例： 12345678910/* 分配 cdev */struct cdev btn_cdev;/* 申请设备号 */if(major)&#123; dev_id = MKDEV(major, 0); register_chrdev_region(dev_id, 1, \"button\"); // 静态申请设备号&#125; else &#123; alloc_chedev_region(&amp;dev_id, 0, 1, \"button\"); // 动态申请设备号 major = MAJOR(dev_id);&#125; 从上面的代码中我们可以看到，申请设备号方式有两种：静态申请和动态申请，其实设备号还有主次之分。 在 Linux 中以主设备号用来标识与设备文件相连的驱动程序。次编号被驱动程序用来辨别操作的是哪个设备。cdev结构体的dev_t成员定义了设备号，为 32 位，其中高 12 位为主设备号，低20 位为次设备号。 设备号的获得与生成： 获得：主设备号：MAJOR(dev_t dev); 次设备号：MINOR(dev_t dev); 生成：MKDEV(int major,int minor); 静态申请设备号函数原型： 12int register_chrdev_region(dev_t from, unsigned count, const char *name);/* 功能：申请使用从from开始的count 个设备号(主设备号不变，次设备号增加） */ 静态申请相对较简单，但是一旦驱动被广泛使用,这个随机选定的主设备号可能会导致设备号冲突，而使驱动程序无法注册。 动态申请设备号函数原型： 12int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,const char *name);/* 功能：请求内核动态分配count个设备号，且次设备号从baseminor开始。 */ 动态申请简单，易于驱动推广，但是无法在安装驱动前创建设备文件（因为安装前还没有分配到主设备号）。 两种方式各有优缺点，可以结合着使用。 初始化cdev12void cdev_init(struct cdev *, struct file_operations *); /* 功能：cdev_init()函数用于初始化 cdev 的成员，并建立 cdev 和 file_operations 之间的连接。 */ 注册cdev12int cdev_add(struct cdev *, dev_t, unsigned);/* 功能：cdev_add()函数向系统添加一个 cdev，完成字符设备的注册. */ 硬件初始化硬件初始化主要是硬件资源的申请与配置，以TQ210的按键驱动为例： 12gpio_request(S5PV210_GPH0(0), \"GPH0_0\"); //申请硬件GPIO资源gpio_direction_input(S5PV210_GPH0(0)); //配置输入 实现设备操作用户空间的程序以访问文件的形式访问字符设备，通常进行open、read、write、close等系统调用。而这些系统调用的最终落实则是file_operations结构体中成员函数，它们是字符设备驱动与内核的接口。以TQ210的按键驱动为例： 1234567/* 设备操作集合 */static struct file_operations btn_fops = &#123; .owner = THIS_MODULE, .open = button_open, .release = button_close, .read = button_read&#125;; 上面代码中的 button_open、button_close、button_read是要在驱动中自己实现的。file_operations结构体成员函数有很多个，下面就选几个常见的来展示： open() 函数1int(*open) (struct inode *, struct file*); read() 函数12ssize_t(*read)(struct file *, char __user*, size_t, loff_t*); /* 功能：用来从设备中读取数据，成功时函数返回读取的字节数，出错时返回一个负值 */ write() 函数12ssize_t(*write)(struct file *, const char__user *, size_t, loff_t*);/* 功能：向设备发送数据，成功时该函数返回写入的字节数。如果此函数未被实现，当用户进行write()系统调用时，将得到-EINVAL返回值 */ close() 函数1int(*release)(struct inode *,struct file*); 补充说明第一点：在Linux字符设备驱动程序设计中，有3种非常重要的数据结构：struct file、struct inode、struct file_operations。 struct file代表一个打开的文件。系统中每个打开的文件在内核空间都有一个关联的struct file。它由内核在打开文件时创建, 在文件关闭后释放。其成员loff_t f_pos 表示文件读写位置。 struct inode 用来记录文件的物理上的信息。因此,它和代表打开文件的 file 结构是不同的。一个文件可以对应多个 file 结构,但只有一个 inode 结构。其成员dev_t i_rdev表示设备号。 struct file_operations 一个函数指针的集合，定义能在设备上进行的操作。结构中的成员指向驱动中的函数,这些函数实现一个特别的操作, 对于不支持的操作保留为 NULL。 第二点：在 read( )和 write( )中的 buff 参数是用户空间指针。因此,它不能被内核代码直接引用，因为用户空间指针在内核空间时可能根本是无效的——没有那个地址的映射。因此，内核提供了专门的函数用于访问用户空间的指针： 1234unsigned long copy_from_user(void *to, const void __user *from, unsigned long count); /* 功能：在内核态下引用用户空间指针 */unsigned long copy_to_user(void __user *to, const void *from, unsigned long count); /* 功能：在用户态下引用内核空间指针 */ 驱动注销删除cdev在字符设备驱动模块卸载函数中通过 cdev_del()函数向系统删除一个cdev，完成字符设备的注销。 12void cdev_del(struct cdev *); // 函数原型cdev_del(&amp;btn_cdev); // 一个实例 释放设备号在调用 cdev_del()函数从系统注销字符设备之后，unregister_chrdev_region()应该被调用以释放原先申请的设备号。 12void unregister_chrdev_region(dev_t from, unsigned count); // 函数原型unregister_chrdev_region(MKDEV(major, 0), 1); // 一个实例 字符设备驱动程序基础cdev结构体在Linux2.6 内核中，使用cdev结构体来描述一个字符设备，cdev结构体的定义如下： 12345678struct cdev &#123; struct kobject kobj; struct module *owner; /* 通常为THIS_MODULE */ struct file_operations *ops; /* 在cdev_init()这个函数里面与cdev结构联系起来 */ struct list_head list; dev_t dev; /* 设备号 */ unsigned int count;&#125;; cdev 结构体的dev_t成员定义了设备号，为 32位，其中 12位是主设备号，20位是次设备号，我们只需使用二个简单的宏就可以从dev_t 中获取主设备号和次设备号： MAJOR(dev_t dev) MINOR(dev_t dev) 相反地，可以通过主次设备号来生成 dev_t： MKDEV(int major,int minor) 操作cdev 结构体1234void cdev_init(struct cdev*,struct file_operations *);struct cdev *cdev_alloc(void);int cdev_add(struct cdev *,dev_t,unsigned);void cdev_del(struct cdev *); 其中（1）用于初始化cdev结构体，并建立cdev与file_operations之间的连接。（2）用于动态分配一个cdev结构，（3）向内核注册一个cdev结构，（4）向内核注销一个cdev结构。 分配和释放设备号在调用cdev_add()函数向系统注册字符设备之前，首先应向系统申请设备号，有二种方法申请设备号，一种是静态申请设备号： 1int register_chrdev_region(dev_t from,unsigned count,const char *name) 另一种是动态申请设备号： 1int alloc_chrdev_region(dev_t *dev,unsigned baseminor,unsigned count,const char *name); 其中，静态申请是已知起始设备号的情况，如先使用 cat /proc/devices 命令查得哪个设备号未事先使用（不推荐使用静态申请）；动态申请是由系统自动分配，只需设置 major = 0 即可。 相反地，在调用 cdev_del()函数从系统中注销字符设备之后，应该向系统申请释放原先申请的设备号，使用： 1void unregister_chrdev_region(dev_t from,unsigned count); cdev结构的file_operations结构体这个结构体是字符设备当中最重要的结构体之一，file_operations 结构体中的成员函数指针是字符设备驱动程序设计的主体内容，这些函数实际上在应用程序进行 Linux 的 open()、read()、write()、close()、seek()、ioctl()等系统调用时最终被调用。 12345678910111213141516171819202122232425262728293031323334353637383940struct file_operations &#123; /* 拥有该结构的模块计数，一般为THIS_MODULE */ struct module *owner; /* 用于修改文件当前的读写位置 */ loff_t (*llseek) (struct file *, loff_t, int); /* 从设备中同步读取数据 */ ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); /* 向设备中写数据 */ ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t); ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t); int (*readdir) (struct file *, void *, filldir_t); /* 轮询函数，判断目前是否可以进行非阻塞的读取或写入 */ unsigned int (*poll) (struct file *, struct poll_table_struct *); /* 执行设备的I/O命令 */ int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long); long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); /* 用于请求将设备内存映射到进程地址空间 */ int (*mmap) (struct file *, struct vm_area_struct *); /* 打开设备文件 */ int (*open) (struct inode *, struct file *); int (*flush) (struct file *, fl_owner_t id); /* 关闭设备文件 */ int (*release) (struct inode *, struct file *); int (*fsync) (struct file *, struct dentry *, int datasync); int (*aio_fsync) (struct kiocb *, int datasync); int (*fasync) (int, struct file *, int); int (*lock) (struct file *, int, struct file_lock *); ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); int (*check_flags)(int); int (*flock) (struct file *, int, struct file_lock *); ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); int (*setlease)(struct file *, long, struct file_lock **);&#125;; file结构file 结构代表一个打开的文件，它的特点是一个文件可以对应多个 file 结构。它由内核再 open时创建，并传递给在该文件上操作的所有函数，直到最后 close函数，在文件的所有实例都被关闭之后，内核才释放这个数据结构。 在内核源代码中，指向 struct file 的指针通常比称为filp，file结构有以下几个重要的成员： 123456789struct file&#123; mode_t fmode; /* 文件模式，如FMODE_READ，FMODE_WRITE */ ...... loff_t f_pos; /* loff_t 是一个64位的数，需要时，须强制转换为32位 */ unsigned int f_flags; /* 文件标志，如：O_NONBLOCK */ struct file_operations *f_op; void *private_data; /* 非常重要，用于存放转换后的设备描述结构指针 */ .......&#125;; inode 结构内核用inode 结构在内部表示文件，它是实实在在的表示物理硬件上的某一个文件，且一个文件仅有一个inode与之对应，同样它有二个比较重要的成员： 1234struct inode&#123; dev_t i_rdev; /*设备编号*/ struct cdev *i_cdev; /*cdev 是表示字符设备的内核的内部结构*/&#125;; 可以从inode中获取主次设备号，使用下面二个宏：12unsigned int imajor(struct inode *inode);unsigned int iminor(struct inode *inode); 字符设备驱动模块加载与卸载函数在字符设备驱动模块加载函数中应该实现设备号的申请和cdev 结构的注册，而在卸载函数中应该实现设备号的释放与cdev结构的注销。 我们一般习惯将cdev内嵌到另外一个设备相关的结构体里面，该设备包含所涉及的cdev、私有数据及信号量等等信息。常见的设备结构体、模块加载函数、模块卸载函数形式如下： 123456789101112131415161718192021222324/* 设备结构体 */struct xxx_dev&#123; struct cdev cdev; char *data; struct semaphore sem; ......&#125;;/*模块加载函数*/static int __init xxx_init(void)&#123; ....... 初始化cdev结构; 申请设备号； 注册设备号； 申请分配设备结构体的内存； // 非必须&#125;/*模块卸载函数*/static void __exit xxx_exit(void)&#123; ....... 释放原先申请的设备号； 释放原先申请的内存； 注销cdev设备；&#125; 字符设备驱动的 file_operations 结构体重成员函数1234567891011121314151617181920212223242526272829303132333435 /* 读设备 */ssize_t xxx_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos) &#123; ...... 使用filp-&gt;private_data获取设备结构体指针； 分析和获取有效的长度； /* 内核空间到用户空间的数据传递 */ copy_to_user(void __user *to, const void *from, unsigned long count); ......&#125; /* 写设备 */ ssize_t xxx_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)&#123; ...... 使用filp-&gt;private_data获取设备结构体指针； 分析和获取有效的长度； /* 用户空间到内核空间的数据传递 */ copy_from_user(void *to, const void __user *from, unsigned long count); ......&#125; /* ioctl函数 */ static int xxx_ioctl(struct inode *inode,struct file *filp,unsigned int cmd,unsigned long arg)&#123; ...... switch(cmd)&#123; case xxx_CMD1: ...... break; case xxx_CMD2: ....... break; default: return -ENOTTY; /* 不能支持的命令 */ &#125; return 0;&#125; 字符设备驱动文件操作结构体模板123456789struct file_operations xxx_fops = &#123; .owner = THIS_MODULE, .open = xxx_open, .read = xxx_read, .write = xxx_write, .close = xxx_release, .ioctl = xxx_ioctl, .lseek = xxx_llseek,&#125;; 上面的写法需要注意二点，一：结构体成员之间是以逗号分开的而不是分号，结构体字段结束时最后应加上分号。 字符设备驱动小结字符设备是3大类设备（字符设备、块设备、网络设备）中较简单的一类设备，其驱动程序中完成的主要工作是初始化、添加和删除cdev结构体，申请和释放设备号，以及填充file_operation结构体中操作函数，并实现file_operations结构体中的read()、write()、ioctl()等重要函数。如图所示为cdev结构体、file_operations和用户空间调用驱动的关系。","categories":[{"name":"基础知识学习","slug":"基础知识学习","permalink":"http://www.zhumark.cn/categories/基础知识学习/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.zhumark.cn/tags/Linux/"},{"name":"Driver","slug":"Driver","permalink":"http://www.zhumark.cn/tags/Driver/"}]}]}